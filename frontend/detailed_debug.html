<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ¤ è¯­éŸ³ç¿»è¯‘ç³»ç»Ÿè¯¦ç»†è°ƒè¯•</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }
        
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        h1 {
            color: #42b983;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .debug-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border-left: 5px solid #42b983;
        }
        
        .log-area {
            height: 200px;
            overflow-y: auto;
            background: #2d2d2d;
            color: #fff;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            margin: 10px 0;
        }
        
        .success { border-color: #28a745; background: #d4edda; color: #155724; }
        .error { border-color: #dc3545; background: #f8d7da; color: #721c24; }
        .warning { border-color: #ffc107; background: #fff3cd; color: #856404; }
        .info { border-color: #17a2b8; background: #d1ecf1; color: #0c5460; }
        
        button {
            background: #42b983;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(66, 185, 131, 0.3);
        }
        
        button:hover {
            background: #359c6d;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(66, 185, 131, 0.4);
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .status-indicator {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 10px;
        }
        
        .status-ready { background: #6c757d; }
        .status-recording { background: #dc3545; animation: blink 1s infinite; }
        .status-processing { background: #ffc107; }
        .status-success { background: #28a745; }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        .test-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        @media (max-width: 768px) {
            .test-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¤ è¯­éŸ³ç¿»è¯‘ç³»ç»Ÿè¯¦ç»†è°ƒè¯•é¢æ¿</h1>
        
        <!-- ç³»ç»ŸçŠ¶æ€æ£€æŸ¥ -->
        <div class="debug-section">
            <h2>ğŸ”§ ç³»ç»ŸçŠ¶æ€æ£€æŸ¥</h2>
            <div id="system-status" class="log-area"></div>
            <button onclick="checkSystemStatus()">ğŸ”„ é‡æ–°æ£€æŸ¥ç³»ç»ŸçŠ¶æ€</button>
        </div>
        
        <!-- å½•éŸ³åŠŸèƒ½æµ‹è¯• -->
        <div class="debug-section">
            <h2>ğŸ™ï¸ å½•éŸ³åŠŸèƒ½æµ‹è¯•</h2>
            <div style="margin: 15px 0;">
                <span class="status-indicator status-ready" id="recording-status"></span>
                <span id="recording-text">å‡†å¤‡å°±ç»ª</span>
            </div>
            <div class="test-grid">
                <div>
                    <button id="start-record-btn" onclick="startDetailedRecording()">â–¶ï¸ å¼€å§‹å½•éŸ³æµ‹è¯•</button>
                    <button id="stop-record-btn" onclick="stopDetailedRecording()" disabled>â¹ï¸ åœæ­¢å½•éŸ³</button>
                </div>
                <div>
                    <button onclick="testMicrophoneAccess()">ğŸ¤ æµ‹è¯•éº¦å…‹é£æƒé™</button>
                    <button onclick="testMediaRecorder()">ğŸ“¹ æµ‹è¯•MediaRecorderæ”¯æŒ</button>
                </div>
            </div>
            <div id="recording-log" class="log-area"></div>
        </div>
        
        <!-- ç½‘ç»œé€šä¿¡æµ‹è¯• -->
        <div class="debug-section">
            <h2>ğŸŒ ç½‘ç»œé€šä¿¡æµ‹è¯•</h2>
            <button onclick="testBackendConnection()">ğŸ”— æµ‹è¯•åç«¯è¿æ¥</button>
            <button onclick="testAudioAPICall()">ğŸµ æµ‹è¯•éŸ³é¢‘APIè°ƒç”¨</button>
            <button onclick="testFullWorkflow()">ğŸ”„ æµ‹è¯•å®Œæ•´å·¥ä½œæµç¨‹</button>
            <div id="network-log" class="log-area"></div>
        </div>
        
        <!-- æ§åˆ¶å°è¾“å‡º -->
        <div class="debug-section">
            <h2>ğŸ–¥ï¸ æ§åˆ¶å°è¾“å‡º</h2>
            <div id="console-output" class="log-area"></div>
            <button onclick="clearConsole()">ğŸ—‘ï¸ æ¸…ç©ºæ—¥å¿—</button>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let consoleOutput = [];
        
        // é‡å†™consoleæ–¹æ³•æ¥æ•è·æ—¥å¿—
        const originalLog = console.log;
        const originalError = console.error;
        const originalWarn = console.warn;
        
        console.log = function(...args) {
            originalLog.apply(console, args);
            addToConsole('log', args.join(' '));
        };
        
        console.error = function(...args) {
            originalError.apply(console, args);
            addToConsole('error', args.join(' '));
        };
        
        console.warn = function(...args) {
            originalWarn.apply(console, args);
            addToConsole('warn', args.join(' '));
        };
        
        // æ·»åŠ åˆ°æ§åˆ¶å°è¾“å‡ºåŒºåŸŸ
        function addToConsole(type, message) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${type.toUpperCase()}: ${message}`;
            
            consoleOutput.push({type, message: logEntry});
            if (consoleOutput.length > 100) {
                consoleOutput.shift();
            }
            
            updateConsoleDisplay();
        }
        
        function updateConsoleDisplay() {
            const consoleEl = document.getElementById('console-output');
            consoleEl.innerHTML = consoleOutput.map(entry => 
                `<div class="${entry.type}">${entry.message}</div>`
            ).join('');
            consoleEl.scrollTop = consoleEl.scrollHeight;
        }
        
        // æ›´æ–°æ—¥å¿—æ˜¾ç¤º
        function updateLog(section, message, type = 'info') {
            const logEl = document.getElementById(section + '-log');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `<div class="${type}">[${timestamp}] ${message}</div>`;
            
            logEl.innerHTML += logEntry;
            logEl.scrollTop = logEl.scrollHeight;
        }
        
        // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºå™¨
        function updateStatusIndicator(status) {
            const indicator = document.getElementById('recording-status');
            const text = document.getElementById('recording-text');
            
            indicator.className = `status-indicator status-${status}`;
            text.textContent = {
                'ready': 'å‡†å¤‡å°±ç»ª',
                'recording': 'æ­£åœ¨å½•éŸ³',
                'processing': 'å¤„ç†ä¸­',
                'success': 'æˆåŠŸ'
            }[status];
        }
        
        // ç³»ç»ŸçŠ¶æ€æ£€æŸ¥
        async function checkSystemStatus() {
            const statusEl = document.getElementById('system-status');
            statusEl.innerHTML = '<div class="info">ğŸ” æ­£åœ¨æ£€æŸ¥ç³»ç»ŸçŠ¶æ€...</div>';
            
            let checks = [];
            
            // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
            checks.push({
                name: 'æµè§ˆå™¨æ”¯æŒ',
                result: typeof MediaRecorder !== 'undefined',
                message: typeof MediaRecorder !== 'undefined' ? 
                    'âœ… MediaRecorder API å¯ç”¨' : 
                    'âŒ MediaRecorder API ä¸å¯ç”¨'
            });
            
            // æ£€æŸ¥HTTPS/localhost
            checks.push({
                name: 'å®‰å…¨ä¸Šä¸‹æ–‡',
                result: location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1',
                message: location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1' ?
                    'âœ… åœ¨å®‰å…¨ä¸Šä¸‹æ–‡ä¸­è¿è¡Œ' :
                    'âš ï¸ å¯èƒ½åœ¨ä¸å®‰å…¨çš„ä¸Šä¸‹æ–‡ä¸­è¿è¡Œ'
            });
            
            // æ£€æŸ¥åç«¯è¿æ¥
            try {
                const response = await fetch('http://127.0.0.1:8000/health', {timeout: 3000});
                checks.push({
                    name: 'åç«¯æœåŠ¡',
                    result: response.ok,
                    message: response.ok ? 
                        `âœ… åç«¯æœåŠ¡æ­£å¸¸ (${response.status})` : 
                        `âŒ åç«¯æœåŠ¡å¼‚å¸¸ (${response.status})`
                });
            } catch (error) {
                checks.push({
                    name: 'åç«¯æœåŠ¡',
                    result: false,
                    message: `âŒ æ— æ³•è¿æ¥åˆ°åç«¯: ${error.message}`
                });
            }
            
            // æ˜¾ç¤ºç»“æœ
            statusEl.innerHTML = checks.map(check => 
                `<div class="${check.result ? 'success' : 'error'}">${check.message}</div>`
            ).join('');
        }
        
        // æµ‹è¯•éº¦å…‹é£æƒé™
        async function testMicrophoneAccess() {
            updateLog('recording', 'ğŸ¤ å¼€å§‹æµ‹è¯•éº¦å…‹é£æƒé™...', 'info');
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                updateLog('recording', 'âœ… éº¦å…‹é£æƒé™è·å–æˆåŠŸ', 'success');
                
                // æ˜¾ç¤ºè®¾å¤‡ä¿¡æ¯
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(device => device.kind === 'audioinput');
                updateLog('recording', `ğŸ§ æ£€æµ‹åˆ° ${audioInputs.length} ä¸ªéŸ³é¢‘è¾“å…¥è®¾å¤‡`, 'info');
                
                // å…³é—­æµ
                stream.getTracks().forEach(track => track.stop());
                
            } catch (error) {
                updateLog('recording', `âŒ éº¦å…‹é£æƒé™è·å–å¤±è´¥: ${error.message}`, 'error');
            }
        }
        
        // æµ‹è¯•MediaRecorderæ”¯æŒ
        function testMediaRecorder() {
            updateLog('recording', 'ğŸ“¹ æµ‹è¯•MediaRecorderæ”¯æŒ...', 'info');
            
            if (typeof MediaRecorder === 'undefined') {
                updateLog('recording', 'âŒ æµè§ˆå™¨ä¸æ”¯æŒMediaRecorder', 'error');
                return;
            }
            
            // æ£€æŸ¥æ”¯æŒçš„MIMEç±»å‹
            const mimeTypes = [
                'audio/webm;codecs=opus',
                'audio/webm',
                'audio/ogg',
                'audio/mp4'
            ];
            
            let supportedTypes = [];
            mimeTypes.forEach(type => {
                if (MediaRecorder.isTypeSupported(type)) {
                    supportedTypes.push(type);
                }
            });
            
            updateLog('recording', `âœ… æ”¯æŒçš„MIMEç±»å‹: ${supportedTypes.join(', ')}`, 'success');
            if (supportedTypes.length === 0) {
                updateLog('recording', 'âŒ æ²¡æœ‰æ‰¾åˆ°æ”¯æŒçš„éŸ³é¢‘æ ¼å¼', 'error');
            }
        }
        
        // è¯¦ç»†çš„å½•éŸ³æµ‹è¯•
        async function startDetailedRecording() {
            if (isRecording) return;
            
            updateLog('recording', 'ğŸ™ï¸ å¼€å§‹è¯¦ç»†å½•éŸ³æµ‹è¯•...', 'info');
            updateStatusIndicator('recording');
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 16000
                    } 
                });
                
                updateLog('recording', 'âœ… éº¦å…‹é£æµè·å–æˆåŠŸ', 'success');
                
                // å°è¯•ä¸åŒçš„MIMEç±»å‹
                const mimeTypes = [
                    'audio/webm;codecs=opus',
                    'audio/webm',
                    'audio/ogg'
                ];
                
                let selectedMimeType = '';
                for (let mimeType of mimeTypes) {
                    if (MediaRecorder.isTypeSupported(mimeType)) {
                        selectedMimeType = mimeType;
                        break;
                    }
                }
                
                mediaRecorder = new MediaRecorder(stream, { 
                    mimeType: selectedMimeType 
                });
                
                updateLog('recording', `âœ… MediaRecorderåˆå§‹åŒ–æˆåŠŸ (MIME: ${selectedMimeType})`, 'success');
                
                audioChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                        updateLog('recording', `ğŸ”Š æ”¶åˆ°éŸ³é¢‘æ•°æ®å—: ${event.data.size} å­—èŠ‚`, 'info');
                        
                        // ç«‹å³æµ‹è¯•å‘é€
                        if (event.data.size > 1000) { // è¶³å¤Ÿå¤§çš„æ•°æ®å—æ‰å‘é€
                            testSendAudioData(event.data);
                        }
                    }
                };
                
                mediaRecorder.onstop = () => {
                    updateLog('recording', 'â¹ï¸ å½•éŸ³å·²åœæ­¢', 'info');
                    updateStatusIndicator('ready');
                };
                
                mediaRecorder.onerror = (event) => {
                    updateLog('recording', `âŒ MediaRecorderé”™è¯¯: ${event.error}`, 'error');
                    updateStatusIndicator('ready');
                };
                
                // æ¯1ç§’è·å–ä¸€æ¬¡æ•°æ®
                mediaRecorder.start(1000);
                isRecording = true;
                
                document.getElementById('start-record-btn').disabled = true;
                document.getElementById('stop-record-btn').disabled = false;
                
                updateLog('recording', 'âœ… å½•éŸ³å·²å¼€å§‹ï¼Œå¯ä»¥è¯´è¯æµ‹è¯•...', 'success');
                
            } catch (error) {
                updateLog('recording', `âŒ å½•éŸ³å¯åŠ¨å¤±è´¥: ${error.message}`, 'error');
                updateStatusIndicator('ready');
            }
        }
        
        function stopDetailedRecording() {
            if (!isRecording || !mediaRecorder) return;
            
            mediaRecorder.stop();
            mediaRecorder.stream.getTracks().forEach(track => track.stop());
            isRecording = false;
            
            document.getElementById('start-record-btn').disabled = false;
            document.getElementById('stop-record-btn').disabled = true;
        }
        
        // æµ‹è¯•å‘é€éŸ³é¢‘æ•°æ®
        async function testSendAudioData(audioBlob) {
            updateLog('network', `ğŸ“¤ å¼€å§‹æµ‹è¯•éŸ³é¢‘æ•°æ®å‘é€... (${audioBlob.size} å­—èŠ‚)`, 'info');
            
            const formData = new FormData();
            formData.append('audio_chunk', audioBlob, 'test_recording.webm');
            formData.append('source_lang', 'zh');
            formData.append('target_lang', 'en');
            
            try {
                const response = await fetch('http://127.0.0.1:8000/api/translate', {
                    method: 'POST',
                    body: formData,
                    timeout: 10000
                });
                
                updateLog('network', `ğŸ“¥ æ”¶åˆ°å“åº”: ${response.status} ${response.statusText}`, 'info');
                
                if (response.ok) {
                    const data = await response.json();
                    updateLog('network', `âœ… ç¿»è¯‘æˆåŠŸ: ${JSON.stringify(data)}`, 'success');
                    updateStatusIndicator('success');
                } else {
                    const errorText = await response.text();
                    updateLog('network', `âŒ ç¿»è¯‘å¤±è´¥: ${response.status} - ${errorText}`, 'error');
                }
                
            } catch (error) {
                updateLog('network', `ğŸ’¥ ç½‘ç»œè¯·æ±‚å¤±è´¥: ${error.message}`, 'error');
            }
        }
        
        // æµ‹è¯•åç«¯è¿æ¥
        async function testBackendConnection() {
            updateLog('network', 'ğŸ”— å¼€å§‹æµ‹è¯•åç«¯è¿æ¥...', 'info');
            
            try {
                const response = await fetch('http://127.0.0.1:8000/health');
                const data = await response.json();
                
                if (response.ok) {
                    updateLog('network', `âœ… åç«¯è¿æ¥æˆåŠŸ: ${JSON.stringify(data)}`, 'success');
                } else {
                    updateLog('network', `âŒ åç«¯è¿”å›é”™è¯¯: ${response.status} - ${data.detail || 'æœªçŸ¥é”™è¯¯'}`, 'error');
                }
            } catch (error) {
                updateLog('network', `ğŸ’¥ åç«¯è¿æ¥å¤±è´¥: ${error.message}`, 'error');
            }
        }
        
        // æµ‹è¯•éŸ³é¢‘APIè°ƒç”¨
        async function testAudioAPICall() {
            updateLog('network', 'ğŸµ å¼€å§‹æµ‹è¯•éŸ³é¢‘APIè°ƒç”¨...', 'info');
            
            // åˆ›å»ºæµ‹è¯•éŸ³é¢‘æ•°æ®
            const audioData = new Uint8Array(2000).fill(128); // ç®€å•çš„æµ‹è¯•æ•°æ®
            const blob = new Blob([audioData], { type: 'audio/webm' });
            
            const formData = new FormData();
            formData.append('audio_chunk', blob, 'test.webm');
            formData.append('source_lang', 'zh');
            formData.append('target_lang', 'en');
            
            try {
                const response = await fetch('http://127.0.0.1:8000/api/translate', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    updateLog('network', `âœ… éŸ³é¢‘APIè°ƒç”¨æˆåŠŸ: ${JSON.stringify(data)}`, 'success');
                } else {
                    updateLog('network', `âŒ éŸ³é¢‘APIè°ƒç”¨å¤±è´¥: ${response.status} - ${data.detail || 'æœªçŸ¥é”™è¯¯'}`, 'error');
                }
            } catch (error) {
                updateLog('network', `ğŸ’¥ éŸ³é¢‘APIè°ƒç”¨å¼‚å¸¸: ${error.message}`, 'error');
            }
        }
        
        // æµ‹è¯•å®Œæ•´å·¥ä½œæµç¨‹
        async function testFullWorkflow() {
            updateLog('network', 'ğŸ”„ å¼€å§‹æµ‹è¯•å®Œæ•´å·¥ä½œæµç¨‹...', 'info');
            
            // 1. æ£€æŸ¥ç³»ç»ŸçŠ¶æ€
            await checkSystemStatus();
            
            // 2. æµ‹è¯•åç«¯è¿æ¥
            await testBackendConnection();
            
            // 3. æµ‹è¯•éŸ³é¢‘API
            await testAudioAPICall();
            
            updateLog('network', 'ğŸ å®Œæ•´å·¥ä½œæµç¨‹æµ‹è¯•å®Œæˆ', 'info');
        }
        
        // æ¸…ç©ºæ§åˆ¶å°
        function clearConsole() {
            consoleOutput = [];
            updateConsoleDisplay();
        }
        
        // é¡µé¢åŠ è½½å®Œæˆåè‡ªåŠ¨æ£€æŸ¥
        window.addEventListener('load', () => {
            console.log('ğŸš€ è°ƒè¯•é¢æ¿å·²åŠ è½½');
            checkSystemStatus();
        });
    </script>
</body>
</html>